
# Разрабатываем утилиту на GraalVM

## Постановка задачи

У меня периодически возникает задача поделиться / передать файлы по локальной сети, 
например коллеге по проекту.

Решений для этого может быть очень много, начиная от Samba / FTP / scp. Можно просто 
залить файл в общедоступное публичное место типа Google Drive, приложить к задаче в Jira, или даже отправить письмом.

Но все это в той или иной степени негибко, где-то требует предварительной настройки и имеет 
свои ограничения (например, максимальный размер вложения).

А хочется чего-то более легковесного и гибкого.

Меня всегда приятно удивляла возможность в линуксе используя подручные средства 
быстро соорудить практическое решение.

Скажем, часто вышеозначенную задачу я решал используя системный питон следующим однострочником

```bash
$ python3 -mhttp.server
Serving HTTP on 0.0.0.0 port 8000 ...
```

Эта команда стартует веб-сервер в текущей папке и позволяет через веб-интерфейс получить список файлов и скачать их.
Больше подобных штук отсыпать тут: https://gist.github.com/willurd/5720255. 

Неудобств тут несколько. Теперь чтоб передать ссылку на скачивание коллеге вам надо знать свой IP адрес в сети.

Для этого удобно использовать команду

```bash
$ ifconfig -a 
``` 
И потом из полученного списка сетевых интерфейсов выбрать подходящий и вручную скомпоновать ссылку вида http://IP:8000 
которую и отправить.

Второе неудобство: этот сервер однопоточен. Это значит что пока один ваш коллега качает файл, второй даже не сможет
загрузить список файлов.

В третьих - это негибко. Если вам надо передать лишь один файл негоже будет открывать всю папку, т.е. придется выполнить
такие телодвижения (а после еще чистить мусор):

```bash
$ mkdir tmp1
$ cp file.zip tmp1
$ cd tmp1
$ python3 -mhttp.server

```

Четвертое неудобство - нет _простого_ способа скачать все содержимое папки.

Для передачи содержимого папки обычно применяют приём называемый [tar pipe](https://docstore.mik.ua/orelly/unix3/upt/ch10_13.htm).

Делают примерно так:
```bash
$ ssh user@host 'cd /path/to/source && tar cf - .' | cd /path/to/destination && tar xvf -
```

Если вдруг непонятно, поясню как это работает. 
Первая часть команды `tar cf - .` созраёт архив содержимого текущей папки и пишет в стандартный
вывод. Дальше этот вывод через pipe передается по защищенному ssh каналу на вход похожей команды `tar xvf -` которая 
делает обратную процедуру, т.е. читает стандартный вход и разархивирует в текущую папку.
Фактически происходит передача архива файлов но без создания промежуточного файла! 

Очевидно и неудобство такого подхода. Нужен ssh доступ с одной машины на другую, а это в общем случае почти никогда не выполняется. 

А можно ли достичь все вышеперечисленное но без этих описанных проблем?

Итак, пришло время формализовать, что будем строить:
1. Программу, которую легко установить (статический бинарник)
1. Которая позволит передавать как файл так и папку со всем содержимым
1. С опциональным сжатием
1. Которая позволит принимающей стороне скачать файл(ы) используя лишь стандартные *nix инструменты (wget/curl/tar)
1. Программа будет после запуска сразу выдавать точные команды для скачивания

## Решение

На конференции [JEEConf](https://jeeconf.com/) которую я посетил не так давно тема [Graal](https://www.graalvm.org/) 
поднималась неоднократно. Тема далеко не новая, но для меня это явилось спусковым крючком чтоб наконец пощупать этого зверя
собственноручно. 

Для тех кто еще не в теме (неужели еще есть такие? oO) напомню, что GraalVM это такая 
прокачанная JVM от Oracle с дополнительными возможностями, самые заметные из которых:
1. Полиглотная JVM - возможность бесшовного совместного запуска Java, Javascript, Python, R, и т.д. кода
1. Поддержка AOT-компиляции - компиляция Java прямо в нативный бинарник
1. Менее заметная но очень крутая фишка - C2 компилятор переписан с C++ на Java с целью более удобной его дальнейшей 
разработки. Это уже дало заметные плоды. Этот компилятор производит гораздо больше оптимизаций на стадии преобразования 
байткода Java в нативный код. Например он способен более эффективно устранять аллокации. В Twitter смогли понизить 
потребление CPU на 11% просто включив эту настройку, что в их масштабах дало заметную экономию ресурсов (и денег).

Освежить представление о Graal можно, например, [в этой хабра-статье](https://habr.com/ru/company/haulmont/blog/433432/).

Писать будем на Java, поэтому для нас самой релевантой возможностью будет AOT-компиляция.

Собственно, результат разработки представлен [в этом Github репозитории](https://github.com/xonixx/serv).

Пример использования для передачи одного файла:

```bash
$ serv '/path/to/report.pdf' 
To download the file please use one of the commands below: 

curl http://192.168.0.179:17777/dl > 'report.pdf'
wget -O- http://192.168.0.179:17777/dl > 'report.pdf'
curl http://192.168.0.179:17777/dl?z --compressed > 'report.pdf'
wget -O- http://192.168.0.179:17777/dl?z | gunzip > 'report.pdf'
```

Пример использования при передаче содержимого папки (все файлы включая вложенные!):

```bash
$ serv '/path/to/folder' 
To download the files please use one of the commands below. 
NB! All files will be placed into current folder!

curl http://192.168.0.179:17777/dl | tar -xvf -
wget -O- http://192.168.0.179:17777/dl | tar -xvf -
curl http://192.168.0.179:17777/dl?z | tar -xzvf -
wget -O- http://192.168.0.179:17777/dl?z | tar -xzvf -
```

Да, так просто!

Обратите внимание - программа сама определяет правильный IP адрес на котором будут доступны файлы для скачивания.

> Использование UPX

Я также надеюсь, что представленная утилита будет полезна хотя-бы кому-то из уважаемого хабра-сообщества.

## Наблюдения

## Выводы